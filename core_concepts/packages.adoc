[[core-components-devices]]
= Packages
:toc: macro
:toc-title:
:data-uri:
:experimental:
:prewrap!:
:description:
:keywords:

toc::[]

== Terminology

=== Executable
An Executable refers to a runnable element. This runnable element can be:

* A Docker image.
* A Git repository and command to run (the platform builds this into a runnable artifact).

[[core_concepts-packages-component]]
=== Component
A component is a list of executables that need to be deployed in unison. That means that these executables can share a specified file path and can
communicate via IPC. Also, any executable listening on a port can be accessed by its sibling executables via `localhost`.

==== Exposing network endpoint from a component
Components can expose network endpoints. The configuration of these endpoint (exposed port, protocol to be use, etc) can be specified during the creation
of the package. The supported protocols are TCP and HTTPS.

[NOTE]
The TCP communication is encrypted via TLS.

==== Required Runtime
The required runtime of a package indicates if the component needs to run on the device or the cloud. The required runtime is optional and can be left
empty in the cases where the component can run either on the device or the cloud.

==== Parameters
Each executable might have a list of parameters whose values differ per deployment. These parameters for the entire component are to be listed while
creating the package along with the default values. When deploying the package, the values of these parameters can be tuned. 
The values of these parameters are set as environment variables in the runtime and can be read by the executables of the component.

==== ROS configuration
For ROS applications, each component can share a list of ROS topics, services, and actions with other components. The executables can subscribe to any
topic or call services or actions that are exposed by other components (see the link:../overview/application_architecture.html[application architecture]).
This configuration should be specified during the creation of the package. 

[NOTE]
The developer does not have to include the ROS master as an executable of a component. The platform manages running ROS master for the developer.

Since this communication can happen over WAN (via the link:../core_concepts/network_layout_communication.html#core_concepts-network-cloud_bridge[cloud bridge])
the developer can tune the level of reliability for the transport layer. The `QoS` (quality of service) attribute of the package reflects this function.
For example `max` QoS for a topic indicates that all messages published to a topic are guaranteed to reach the subscribers of the topic. The offered QoS
values are `max`, `hi`, `med`, `low`. 

.*Why not just use “max” QoS for all topics?*
[IMPORTANT]
QoS is proportional to the latency of the message: the average latency of `max` QoS topics is higher than of `med` topics.

== Package
A Package is the smallest unit of deployment in rapyuta.io. A package is a composition of software components that can be deployed on devices, cloud or both.
A package needs to be added to the service catalog before it can be deployed. 

=== Plans
All components are part of a specific plan. A package contains multiple of such plans. Plans allow the author of a package to offer different plans with
different components and different configuration. When deploying a package, the deployer chooses a plan for the package he/she wants to deploy.

Every plan can expose a set parameters from its components. These parameters can be used when this package (the one that this plan belongs to) is used as
a dependency. These parameters can be specified in the *exposed parameters* section of a plan.

.*Example*
[NOTE]
The author of a ROS talke-listener package can offer two plans, one with a ROSBridge and one without, the user of the package can choose one of these
plans at the time of deployment.

[TIP]
As a guideline, applications that are very similar but differ in either configuration or might have/lack an extra component should be described as
different plans within a package rather than describing them in different packages.

=== Dependencies
A package can depend on other packages from the service catalog. For example, your ROS application might need to use the ROSBridge suite to push data to a
web interface. And you might have the ROSBridge suite as a different package in the service catalog. In this case, it can be specified as a dependency of
the application

When a package *A* is added as a dependency for Package *B*, the *exposed parameters* and *exposed network endpoints* of *A*'s chosen
plan are added as environment variables for the components of *B*. This ensures that the components of *B* can access the endpoints and parameters exposed
by *A”*.

[NOTE]
The components of *B* might have parameters which are also stored as environment variables in the runtime. This leads to a possibility of collisions that
rapyuta.io does not solve at this point of time.
