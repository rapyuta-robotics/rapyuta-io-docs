= Service Catalog

The service catalog is a curated collection of public and private packages. It can be used to accelerate development by focusing on modularity and
reusability of packages. The design patterns section helps get you started with composing your applications

[NOTE]
If a user creates a package in a group, all members of this group have access to this package. If he/she were to create a package outside the scope
of any group, only he/she would have access to this package.

== Design Patterns with RapyutaIO

== Overview
Often while building complex robotic applications different parts of the application are developed in completely different processes, 
using different languages and often by people form different domains
For instance the front-end team may use ReactJS and is comprised of mainly web developers, 
while the onboard team uses C/C++ and hosts many hardware experts and 
on the other hand the navigation and task planning team may write software that lives in the cloud and use OpenCL, Python or Java. 
These teams have different needs, different development cycles and depend on *complete* running instances of each others components, 
including the version and deployment life-cycle). It is vital that the platform allows for these scenarios.

There are two key design patterns rapyuta IO enables.

=== Package  Inheritance
A package can *include* a package from the service catalog into another package to arrive at the resultant result.

For instance, a fancy *robot teleop* package may require a real-time video gateway.

It makes sense to abstract out the video streaming logic and all the underlying complex infrastructure into a `simple_video_gateway` use this for different kinds of robots - perhaps an AGV and a drone.

For example You could also use this for a simple `AGV_teleop` that moves a AGV about in a 2D plane and simply include the `simple_video_gateway`. 
You could now focus on writing the `drone_teleop` code that controls the direction, altitude and  gimbal pose and simply include the `simple_video_gateway` and have that provide the required interfaces.

Here you essentially provision an instance of `simple_video_gateway` every time you provision an instance of either `agv_teleop` or `drone_teleop`. This may be a sane choice given the compute and latency requirements of typical infrastructure that handles video streaming. 


[NOTE]
The components of *B* included in this way might have parameters which are also stored as environment variables in the runtime. This leads to a possibility of collisions that
rapyuta.io does not solve at this point in time.

==== Singleton Packages 
The platform also allows you a choice to declare a package as a `singleton` suppose you had a fancy `video_streaming` algorithm that supported multiple endpoints and did all the muxing required you could use this. The package `fancy_video_gateway` would be instantiated only on the first requests and further requests would implicitly bind to the existing instance achieving the desired result. Without you having to explicitly control this. The actual mechanics would be handled similar to the Dependant deployment technique illustrated in the next section. The deployment binding id would be implicitly handled by the system

=== Dependant Deployments

Dependant deployments are a common design pattern where you wish to control the life-cycle of a set of components independently and `bind` them at runtime. A good  example would be a `cloud_mapping_service` which is a component that maintains a global map of your warehouse, this is a long running service. Multiple robots use this to reason get information about the map environment around them and update it with obstacles that other may use. When a robot comes online its `cool_agv_bot` component connects to the `cloud_mapping_service` to the service and proceeds to do its missions.
 Each running deployment is identified by a `deployment_id`. This is id is exposed to formulate dependencies on this deployment instance. 

A good example is a component that maintains a global map of your warehouse, called a `cloud_mapping_service`. This is a long running service.
Multiple robots use this to retrieve information about the environment around them and update it with obstacles that other robots may use. When a robot comes online its `cool_agv_bot` component connects to the `cloud_mapping_service` service and proceeds to do its missions.

At this point all topics, services and actions provided by `cloud_mapping_service` are locally available in each instance of `cool_agv_bot`. 
However the *inboundROSinterfaces* field in the `cloud_mapping_service` require the developer to provide a whitelist of topics, actions and services allowed from the child deployments i.e (`cool_agv_bot`)

[NOTE]
When a package *A* is added as a dependency for Package *B*, the *exposed parameters* and *exposed network endpoints* of *A*'s chosen plan are added as environment variables for the components of *B*. This ensures that the components of *B* can access the endpoints and parameters exposed
by *A‚Äù*.


== Third Party services
rapyuta.io provides some commonly used packages that any user can use to accelerate their application development. 
