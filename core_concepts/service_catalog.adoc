= Service Catalog
:toc: macro
:toc-title:
:data-uri:
:experimental:
:prewrap!:
:description:
:keywords:

toc::[]

The service catalog is a curated collection of public and private packages. It can be used to accelerate development by focusing on modularity and
reusability of packages. The design patterns section helps get you started with composing your applications.

[NOTE]
If a user creates a package in a group, all members of this group have access to this package. If he/she were to create a package outside the scope
of any group, only he/she would have access to this package.

== Design Patterns with Rapyuta.IO

== Overview
Often while building complex robotic applications, different parts of the application are developed in completely different processes, 
using different languages and often by people form different domains.
For instance, the front-end team may use ReactJS, the device development team uses C/C++, and the navigation and task planning team may write software that lives in the cloud and use OpenCL, Python or Java. 
These teams have different needs, different development cycles and depend on *complete* running versioned instances of each others components. 
It is vital that the platform allows for these scenarios.

rapyuta.io enables two key design patterns.

=== Package  Inheritance
A package may *include* another package from the service catalog when being declared to achieve the required composition. 
This is the suggested pattern when the developer needs to compose the desired behavior from one or more packages 
and requires tight one-to-one coupling between the packages and their instantiation and life-cycle. 

image::package_include.png["Catalog Include"]

For instance, a fancy *robot_teleop* package may require a "real-time video gateway".

It would be useful to abstract out the video streaming logic and all the underlying complex infrastructure into a *simple_video_gateway* 
and re-use this for different kinds of robots - perhaps an AGV and a drone.

The developer of the *agv_teleop* package can quickly build a package that controls the motion of an AGV in a 2D plane and 
include the *simple_video_gateway*  without having to deal with the added complexities of real-time video streaming.

Meanwhile the developer of a more complex  *drone_teleop* package can focus on the complexities associated with getting precise direction, altitude and  gimbal pose control 
and include the *simple_video_gateway* to achieve the desired result.


On every deployment request of either *agv_teleop* or *drone_teleop* the rapyuta.io platform implicitly provisions a new instance of *simple_video_gateway*.

[NOTE]
====
Singleton Package Plans

If a package *multi_video_streaming* had a plan that supported multiple endpoints concurrently within a single deployment 
the author can choose to declare the package plan as a *singleton*. 
The platform would only instantiate the package plan on the first deployment request. 

====
When a package *PkgA* is included in Package *PkgB*, the *exposed configuration parameters* and *exposed network endpoints* of *PkgA*'s 
chosen plans are added as environment variables for the components of *PkgB*. 
This ensures that the components of *PkgB* can access the endpoints and parameters exposed by *PkgA*.

[WARNING]
The components of *B* might have configuration parameters which are also stored as environment variables in the runtime. 
This leads to a possibility of collisions that rapyuta.io does not solve at this point in time.



=== Dependant Deployments

"Dependant Deployments" is a design pattern which allows the user to control the life-cycle of a set of components independently and *bind* 
them at the package instantiation.
This is the suggested pattern when the developer needs to compose the desired behavior by loosely coupling packages that follow different life-cycles,
 for instance the coupling between multiple short lived agents and a long running/stateful shared (many-to-one).

image::dependant_deploy.png["Dependant Deployment"]

A good example is a component that maintains a global map of your warehouse, called a *cloud_mapping_service*. This is a long running service.
Multiple robots use this to retrieve information about the environment around them and update it with obstacles that other robots may use. 
When a robot comes online its *agv_bot* component connects to the *cloud_mapping_service* service and proceeds to do its missions.
Each running deployment is identified by a *deployment_id*. This is id is exposed to formulate dependencies on this deployment instance. 

At this point *all* topics, services and actions provided by *cloud_mapping_service* are locally available in every instance of *agv_bot*. 
However the *inboundROSinterfaces* field in the *cloud_mapping_service* require the developer to provide a whitelist of topics, 
actions and services allowed from the child deployments i.e (`agv_bot`)

== Third Party Services
rapyuta.io provides some commonly used packages that any user can use to accelerate their application development. 
