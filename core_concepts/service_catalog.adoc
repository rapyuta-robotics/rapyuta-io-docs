= Service Catalog

The service catalog is a curated collection of public and private packages. It can be used to accelerate development by focusing on modularity and
reusability of packages. The design patterns section helps get you started with composing your applications

[NOTE]
If a user creates a package in a group, all members of this group have access to this package. If he/she were to create a package outside the scope
of any group, only he/she would have access to this package.

== Design Patterns with RapyutaIO

== Overview
Reusing code libraries is common in software development. Often in building complex robotic applications this may be practical and insufficient. 
Different parts of the application are developed in completely different process, using different languages and often by people form different domains
For instance the front-end team may use ReactJS and are web developers, the onboard team uses C/C++ and are hardware experts and the navigation and task planning team may write software that lives in the cloud and use OpenCL, Python and Java. These teams have different needs, different development cycles and depend on complete running components (including the version and deployment life-cycle) for the final product to actually work.

There are *two* key design patterns rapyuta IO enables.

=== Package  Inheritance
A package can *include* a package from the service catalog into another package to arrive at the resultant result.

For instance, a fancy *robot teleop* package may require a real-time video gateway.

It makes sense to abstract out the video streaming logic and all the underlying complex infrastructure into a `simple_video_gateway` use this for different kinds of robots - perhaps an AGV and a drone.

For example You could also use this for a simple `AGV_teleop` that moves a AGV about in a 2D plane and simply include the `simple_video_gateway`. 
You could now focus on writing the `drone_teleop` code that controls the direction, altitude and  gimbal pose and simply include the `simple_video_gateway` and have that provide the required interfaces.

Here you essentially provision an instance of `simple_video_gateway` every time you provision an instance of either `agv_teleop` or `drone_teleop`. This may be a sane choice given the compute and latency requirements of typical infrastructure that handles video streaming. 


[NOTE]
The components of *B* might have parameters which are also stored as environment variables in the runtime. This leads to a possibility of collisions that
rapyuta.io does not solve at this point in time.

==== Singleton Packages 
The platform also allows you a choice to declare a package as a `singleton` suppose you had a fancy `video_streaming` algorithm that supported multiple endpoints and did all the muxing required you could use this. The package `fancy_video_gateway` would be instantiated only on the first requests and further requests would implicitly bind to the existing instance achieving the desired result. Without you having to explicitly control this. The actual mechanics would be handled similar to the Dependant deployment technique illustrated in the next section. The deployment binding id would be implicitly handled by the system

=== Dependant Deployments

This is a common design pattern where you wish to control the life-cycle of a set of components independently and `bind` them at runtime. A good  example would be a `cloud_mapping_service` which is a component that maintains a global map of your warehouse, this is a long running service. Multiple robots use this to reason get information about the map environment around them and update it with obstacles that other may use. When a robot comes online its `cool_agv_bot` component connects to the `cloud_mapping_service` to the service and proceeds to do its missions.

At this point you could start the catalog package you built called `cloud_mapping_service` and grab its deployment_id (the id of the running instance of the package). You can now make new instantiations of `cool_agv_bot` depend on the deployment_id of the `cloud_mapping_service`.

At this point all topics, services and actions provided by `cloud_mapping_service` are locally available in each instance of `cool_agv_bot`. 
However the *inboundROSinterfaces* field in the `cloud_mapping_service` require the developer to provide a whitelist of topics, actions and services allowed from the child deployments i.e (`cool_agv_bot`)

[NOTE]
When a package *A* is added as a dependency for Package *B*, the *exposed parameters* and *exposed network endpoints* of *A*'s chosen plan are added as environment variables for the components of *B*. This ensures that the components of *B* can access the endpoints and parameters exposed
by *A‚Äù*.


== Third Party services
rapyuta.io provides some commonly used packages that any user can use to accelerate their application development. 
